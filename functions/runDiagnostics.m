function [ cDiagnostics ] = runDiagnostics(iPeriod, cSettings, cDiagnostics, cData, mdDataSlice, cHMM, iHMMused, cTree  )
%runDiagnostics summary and diagnostic functions and plots
%
%   * calculates optimal asset allocation using MA & MVPT
%
%   Input:
%   iPeriod:        number of rolling period that called the function
%   cSettings:      structure of settings, as specified in Runtime.m
%   cDiagnostics:   structure of diagnostic summary statistics 
%   cData:          structure of data, as returned by dataImport
%   mdDataSlice:    matrix of current data subset
%   cHMM:           structure of HMMs, generated by calibrateHMM
%   iHMMused:       index of selected HMM in cHMM
%   cTree:          structure of scenario tree
%
%   Output:
%   cDiagnostics:   structure of diagnostic summary statistics 

%% Input
viStates = [cHMM.NoStates];
iNStates = cHMM(iHMMused).NoStates;
iNAssets = length(cSettings.Securities)+1;

%% Import Statistics
cRowLabels = {'No of observations', 'Missing data', 'Missing observations in \%', 'Mean of Returns / Rate $\mu_i$','Std. Dev. of Returns / Rate $\sigma_i$'};
cSecuritiesLabels = cell(1,iNAssets);
cSecuritiesLabels{1} = 'LIBOR';
for i=1:iNAssets
    cSecuritiesLabels{i} =  cData(i).Asset; %sprintf('%s',strrep(cSettings.Securities{i},'^',''));
end
if (iPeriod == 1)
    mdImportDiag = nan(5,iNAssets);
    mdImportDiag(1,:) = ones(1,iNAssets) * cDiagnostics.ImportStats.NObs;
    mdImportDiag(2,:) = cDiagnostics.ImportStats.NMissing;
    mdImportDiag(3,:) = cDiagnostics.ImportStats.MissingPercent*100;
    for i=1:iNAssets
        mdImportDiag(4,i)= mean(cData(i).Returns);
        mdImportDiag(5,i)= std(cData(i).Returns);
    end
    cDiagnostics(iPeriod).ImportStats.Mus = mdImportDiag(4,:);
    cDiagnostics(iPeriod).ImportStats.Std = mdImportDiag(5,:);
    matrix2latex(mdImportDiag, strcat(cSettings.TableFolder,'\ImportStats.tex'), 'rowLabels', cRowLabels, 'columnLabels', cSecuritiesLabels, 'alignment', 'c', 'format', '%-6.2f');
    
    % Return series - Total
    %         plot(repmat(cData(1).Dates,1,iNAssets),[cData.EquityCurve]);
    h = plotEquityCurve(cData(1).Dates, [cData.EquityCurve],cSecuritiesLabels, '\textbf{Equity Curves}');
    savePlot(h,strcat(cSettings.PlotFolder,'\EquityCurves.pdf'));
end

%% HMMs
mdHMMDiag = nan(3,length(viStates));
mdHMMDiag(1,:) = abs([cHMM.LogLik]);
mdHMMDiag(2,:) = cDiagnostics(iPeriod).AICWeights;
mdHMMDiag(3,:) = cDiagnostics(iPeriod).BICProb;
cRowLabels = {'LL $\log(\mathcal{L} (\hat{\Theta}|data)$', 'AIC $\omega_i$', 'BIC $p_i$'};
cStatesLabels = cell(1,length(cSettings.NoStates));
for i=1 : length(viStates)
    cStatesLabels{i} =  sprintf('%d States',viStates(i));
end
matrix2latex(mdHMMDiag, strcat(cSettings.TableFolder,'\HMMTable_',num2str(iPeriod),'.tex'), 'rowLabels', cRowLabels, 'columnLabels', cStatesLabels, 'alignment', 'c', 'format', '%-6.2f');

%% Transition Matrix
cDiagnostics(iPeriod).TransitionMatrix = cHMM(iHMMused).TransitionMatrix;
writeMat2Latex(cHMM(iHMMused).TransitionMatrix, strcat(cSettings.TableFolder,'\TransMatrix_',num2str(iPeriod),'.tex'), 'before', {'\mathbf{T}_{\delta t}='}, 'format', '%-6.4f');

%% AIC BIC piechart
h = plotAICPieChart(cDiagnostics(iPeriod).AICWeights, cStatesLabels');
savePlot(h,strcat(cSettings.PlotFolder,'\AICBICPieChart_',num2str(iPeriod),'.pdf'));

%% Viterbi of Rolling Period
mdRollingEquityCurve = equityCurve(mdDataSlice(:,3:end),1,'Continuous');
if (find(cData(1).Dates == mdDataSlice(1,1)) ==1 )
    viDates =[datenum(cSettings.DataStart); cData(1).Dates(find(cData(1).Dates == mdDataSlice(1,1)):find(cData(1).Dates == mdDataSlice(end,1)),:)];
else
    viDates = cData(1).Dates(find(cData(1).Dates == mdDataSlice(1,1))-1:find(cData(1).Dates == mdDataSlice(end,1)),:);
end

[h, mdViterbi] = plotViterbiSequence(viDates, mdRollingEquityCurve, cSecuritiesLabels, cHMM(iHMMused).Mu , cHMM(iHMMused).ViterbiPath);
savePlot(h,strcat(cSettings.PlotFolder,'\ViterbiEquityCurves_',num2str(iPeriod),'.pdf'));
cDiagnostics(iPeriod).mdViterbi = mdViterbi;

%% JB Test on  Viterbi States
for i=1:iNStates
    mdViterbiData = mdDataSlice(find(mdViterbi(2:end,2)==i),3:end);
    if (size(mdViterbiData,1) <=1)
        cDiagnostics(iPeriod).JBTest(i,:) =NaN(1,iNAssets-1);
    else
        for j=1:iNAssets-1
            cDiagnostics(iPeriod).JBTest(i,j) = jbtest(mdViterbiData(:,j));
        end
    end
end

%% Plot Distributions
close all;
h = figure();
set(h,'Visible', 'off');
sFontName = 'Palatino';
iTitleFontSize = 16;
iLabelFontSize = 14;
dLim = 3.0;
dStep = 0.2;
iSelStage = 1;
iSelState = 1;
for i=1:iNStates+1
    if (i==2)
        iSelStage = 2;
        iSelState = 1;
    end
    switch iNAssets
        case 1
            vdMu = cTree{iSelState,iSelStage}.Distribution.Mu;
            mdSigma = cTree{iSelState,iSelStage}.Distribution.Sigma;
            x1 = -dLim:dStep:dLim;
            F = mvnpdf([x1(:)],vdMu,mdSigma);
            plot(x1,F);
            axis([-dLim dLim 0 1.1*max(max(F))]);
            xlabel(cSecuritiesLabels{1},'Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
            ylabel('Probability Density','Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
        case 2
            vdMu = cTree{iSelState,iSelStage}.Distribution.Mu';
            mdSigma = cTree{iSelState,iSelStage}.Distribution.Sigma;
            x1 = -dLim:dStep:dLim; x2 = x1;
            [X1,X2] = meshgrid(x1,x2);
            F = mvnpdf([X1(:) X2(:)],vdMu,mdSigma);
            F = reshape(F,length(x2),length(x1));
            surf(x1,x2,F);
            caxis([min(F(:))-.5*range(F(:)),max(F(:))]);
            axis([-dLim dLim -dLim dLim 0 1.1*max(max(F))]);
            xlabel(cSecuritiesLabels{1},'Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
            ylabel(cSecuritiesLabels{2},'Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
            zlabel('Probability Density','Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
        case 3
            vdMu = cTree{iSelState,iSelStage}.Distribution.Mu';
            mdSigma = cTree{iSelState,iSelStage}.Distribution.Sigma;
            x1 = -dLim:dStep:dLim;
            [X1,X2,X3] = sphere(length(x1));
            ap = [X1(:) X2(:) X3(:)]';
            [v, d] =eig(mdSigma);
            bp = (v*sqrt(d)*ap) + repmat(vdMu', 1, size(ap,2));
            xp = reshape(bp(1,:),size(X1));
            yp = reshape(bp(2,:),size(X2));
            zp = reshape(bp(3,:),size(X3));
            surf(xp, yp, zp);
            xlabel(cSecuritiesLabels{1},'Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
            ylabel(cSecuritiesLabels{2},'Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
            zlabel(cSecuritiesLabels{3},'Fontname',sFontName,'FontSize',iLabelFontSize,'Interpreter','latex');
            %Plots the distribution specified by Means M and Covariance
            %Matrix as an ellipsoid in 3-d
        otherwise
            error('iNAssets > 3 not implemented')
    end
    iSelState = iSelState+1;
    % Mu / Sigma / Plot for each state
    if (iSelStage ==1)
        writeMat2Latex(vdMu', strcat(cSettings.TableFolder,'\Mu_',num2str(i),'.tex'), 'before', {strcat('\hat{\mu}=')}, 'format', '%-6.4f');
        writeMat2Latex(mdSigma, strcat(cSettings.TableFolder,'\Sigma_',num2str(i),'.tex'), 'before', {strcat('\hat{\Sigma}=')}, 'format', '%-6.4f');
        
    else
        writeMat2Latex(vdMu', strcat(cSettings.TableFolder,'\Mu_',num2str(i),'.tex'), 'before', {strcat('\mu_',num2str(i-1),'=')}, 'format', '%-6.4f');
        writeMat2Latex(mdSigma, strcat(cSettings.TableFolder,'\Sigma_',num2str(i),'.tex'), 'before', {strcat('\Sigma_',num2str(i-1),'=')}, 'format', '%-6.4f');
    end
    title('\textbf{Return Distribution}','Fontname',sFontName,'FontSize',iTitleFontSize,'Interpreter','latex')
    set(gcf, 'Color', 'w');
    savePlot(h,strcat(cSettings.PlotFolder,'\DistributionPlot',num2str(i),'_',num2str(iPeriod),'.pdf'));
end

%% Plot MVPT Efficient Frontier
h = plotMVPTEfficientFrontier(vdMu',mdSigma);
savePlot(h,strcat(cSettings.PlotFolder,'\MVPTEfficientFrontier_',num2str(iPeriod),'.pdf'));

%% Plot MA Efficient Frontier
h = plotMAEfficientFrontier(vdMu',mdSigma, [cSettings.H],[cSettings.Alpha]);
savePlot(h,strcat(cSettings.PlotFolder,'\MAEfficientFrontier_',num2str(iPeriod),'.pdf'));

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This source code is part of RSMentalAccounting.
%
% Copyright(c) 2014 Felix Andresen
% All Rights Reserved.
%
% This program shall not be used, rewritten, or adapted as the basis of a commercial software
% or hardware product without first obtaining written permission of the author. The author make
% no representations about the suitability of this software for any purpose. It is provided
% "as is" without express or implied warranty.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Written by
%   Felix Andresen  
%   Master Thesis:  Regime Switching Models and the Mental Accounting Framework
%   Advisors:       Prof. Jan Vecer, Prof. Sebastien Lleo
%   Master of Science in Quantitative Finance, Frankfurt School of Finance and Management
%   Frankfurt am Main, Germany
%   02/2014
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Contact
%   E-mail: Felix.Andresen@gmail.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%